---
layout: post
title: Running interactive programs uninteractively in Bash scripts
date: '2012-02-08T13:02:00.000+01:00'
author: A Penguin in Redmond
tags:
- Bash
- Programming
- linux
modified_time: '2020-03-12T09:57:13.843+01:00'
permalink: /2012/02/running-interactive-programs.html
---

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script><p>Bash scripts are great for automating tasks. Some challenges arise though when you want to automate a process that involves programs that ask for user input by keyboard. You know, the kind of program that keeps asking things like: "Are you sure you want to do this (y/n)?". Most programs accept arguments that enable some kind of "non-interactive mode" for that. For example, <pre class="prettyprint"><br />rm -i somefile<br /></pre>asks for confirmation before deleting <i>somefile</i>, while <pre class="prettyprint"><br />rm -f somefile<br /></pre>does not. This of course makes the latter a lot more suitable for use in automated scripts. Unfortunately, not all programs provide these kind of arguments. What to do with them? 
<!--end_excerpt-->
<p>One option is to use redirection and echo the input into them, like so: <pre class="prettyprint"><br />echo "yes" | rm -i somefile<br /></pre>or, if you want to remove a lot of files (and for some reason don't want to replace the -i argument with -f), with the brilliant command <i>yes</i>: <pre class="prettyprint"><br />yes | rm -i somefile*<br /></pre><p>Things start to look ugly though when you have to provide a lot of different input texts. Say you have a program <i>generate_random_files</i> which, well, generates random files after asking in sequence:  <ol><li>How many files?</li><li>Size of files?</li><li>Are you sure (y/n)?</li></ol>Suppose our answer to the first question is <i>2</i>, to the second question <i>4</i>, and the third one <i>y</i>. Providing the input could be accomplished by: <pre class="prettyprint"><br />/bin/echo -e "2\n4\ny" | generate_random_files<br /></pre>but it doesn't look particularly readable. Another option would be to create a text file <i>input.txt</i> with contents: <pre><br />2<br />4<br />y<br /></pre>and then invoke the program with redirected input from this file: <pre class="prettyprint"><br />generate_random_files &lt; input.txt<br /></pre><p>This gives you one more file to manage though. Also, it makes it clumsy to use Bash variables in the input. For example, if you want a file size not of 4, but of some variable $calculatedSize, then you would have to manipulate the text file from within your script before calling <i>generate_random_files</i>. <p>An elegant way to do it is to use what is called "here documents", which allows you to basically put the literal contents of <i>input.txt</i> right in your script, eliminating the need for a separate file and allowing use of variables, while keeping things reasonably human-readable. The syntax is: program name followed by &lt;&lt; followed by a unique delimiter of your own choosing, then on a new line the text that serves as input for the program, and then on a new line (and not preceded by any spaces or tabs!) the delimiter again. Like in this little script: <pre class="prettyprint"><br />#!/bin/bash<br />echo "Starting generate_random_files..."<br />generate_random_files &lt;&lt;TextForInput<br />2<br />4<br />y<br />TextForInput<br />echo "Finished!"<br /></pre>And here's the same example, but using a variable which holds the size in bytes, calculated based on the argument $1 that provides the size in kilobytes: <pre class="prettyprint"><br />#!/bin/bash<br />sizeInKb=$1<br />calculatedSize=$((1024*$sizeInKb))<br />echo "Starting generate_random_files..."<br />generate_random_files &lt;&lt;TextForInput<br />2<br />$calculatedSize<br />y<br />TextForInput<br />echo "Finished!"<br /></pre>